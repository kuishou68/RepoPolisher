import { spawn } from 'child_process';
import type { SpawnOptionsWithoutStdio } from 'child_process';
import type { PRDraft, PRSubmitResult } from '@repo-polisher/shared';
import { getGhSpawnConfig } from './gh-env';

export interface GhCliOptions {
  workDir: string;
}

export class GhCli {
  private workDir: string;
  private ghCommand: string;
  private ghEnv: NodeJS.ProcessEnv;

  constructor(options: GhCliOptions) {
    this.workDir = options.workDir;
    const ghConfig = getGhSpawnConfig();
    if (!ghConfig.available) {
      throw new Error('GitHub CLI (gh) is not available. Please install it or set GH_CLI_PATH.');
    }
    this.ghCommand = ghConfig.command;
    this.ghEnv = ghConfig.env;
  }

  async createPR(draft: PRDraft): Promise<PRSubmitResult> {
    try {
      const upstreamSlug = await this.getRemoteSlug('origin');
      let headRef: string | undefined = draft.branch;
      let pushRemote = 'origin';

      // Create branch
      await this.runGitOrThrow(['checkout', '-b', draft.branch], 'Failed to create branch');

      // Apply changes (files should already be modified)
      await this.runGitOrThrow(['add', '-A'], 'Failed to stage changes');
      await this.runGitOrThrow([
        'commit',
        '-m',
        draft.title,
        '-m',
        'Generated by RepoPolisher',
      ], 'Failed to commit changes');

      // Push branch
      try {
        await this.runGitOrThrow(['push', '-u', pushRemote, draft.branch], 'Failed to push branch');
      } catch (error) {
        if (this.isPermissionError(error)) {
          const forkSlug = await this.ensureForkRemote(upstreamSlug);
          pushRemote = 'fork';
          headRef = `${forkSlug.owner}:${draft.branch}`;
          await this.runGitOrThrow(
            ['push', '-u', pushRemote, draft.branch],
            'Failed to push branch to fork'
          );
        } else {
          throw error;
        }
      }

      // Create PR using gh
      const prArgs = [
        'pr',
        'create',
        '--title',
        draft.title,
        '--body',
        draft.body,
        '--base',
        draft.baseBranch,
        '--repo',
        upstreamSlug,
      ];

      if (headRef) {
        prArgs.push('--head', headRef);
      }

      const result = await this.runGh(prArgs);

      if (!result.success) {
        return {
          success: false,
          error: result.output,
        };
      }

      // Parse PR URL from output
      const urlMatch = result.output.match(/https:\/\/github\.com\/[^\s]+\/pull\/\d+/);
      const prUrl = urlMatch ? urlMatch[0] : undefined;
      const prNumber = prUrl ? parseInt(prUrl.split('/').pop() || '0', 10) : undefined;

      return {
        success: true,
        prUrl,
        prNumber,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  async forkRepo(owner: string, repo: string): Promise<boolean> {
    const result = await this.runGh(['repo', 'fork', `${owner}/${repo}`, '--clone=false']);
    return result.success;
  }

  async cloneRepo(owner: string, repo: string, targetDir: string): Promise<boolean> {
    const result = await this.runGh(['repo', 'clone', `${owner}/${repo}`, targetDir]);
    return result.success;
  }

  private runGit(args: string[]): Promise<{ success: boolean; output: string }> {
    return this.runCommand('git', args);
  }

  private async runGitOrThrow(args: string[], errorMessage: string): Promise<void> {
    const result = await this.runGit(args);
    if (!result.success) {
      throw new Error(`${errorMessage}: ${result.output}`);
    }
  }

  private runGh(args: string[]): Promise<{ success: boolean; output: string }> {
    return this.runCommand(this.ghCommand, args, { env: this.ghEnv });
  }

  private async getRemoteSlug(remote: string): Promise<string> {
    const result = await this.runGit(['config', '--get', `remote.${remote}.url`]);
    if (!result.success) {
      throw new Error(`Failed to read git remote ${remote}`);
    }
    return this.parseGitHubSlug(result.output.trim());
  }

  private parseGitHubSlug(url: string): string {
    const cleaned = url.replace(/\.git$/, '');
    if (cleaned.startsWith('git@')) {
      const match = cleaned.match(/github\.com:(.+)/i);
      if (match?.[1]) {
        return match[1];
      }
    }

    try {
      const parsed = new URL(cleaned);
      const parts = parsed.pathname.replace(/^\/+/, '').split('/');
      if (parts.length >= 2) {
        return `${parts[0]}/${parts[1]}`;
      }
    } catch {
      // ignore
    }

    throw new Error(`Unable to parse GitHub repository from ${url}`);
  }

  private async ensureForkRemote(upstreamSlug: string): Promise<{ owner: string; repo: string }> {
    const username = await this.getGitHubUsername();
    if (!username) {
      throw new Error('Failed to determine GitHub username for forking');
    }

    const [, repo] = upstreamSlug.split('/');
    const forkSlug = `${username}/${repo}`;

    const forkResult = await this.runGh([
      'repo',
      'fork',
      upstreamSlug,
      '--clone=false',
      '--remote=false',
    ]);

    if (!forkResult.success && !forkResult.output.toLowerCase().includes('already exists')) {
      throw new Error(`Failed to fork repository: ${forkResult.output}`);
    }

    const forkUrl = `https://github.com/${forkSlug}.git`;
    const remoteResult = await this.runGit(['remote', 'get-url', 'fork']);
    if (remoteResult.success) {
      await this.runGitOrThrow(['remote', 'set-url', 'fork', forkUrl], 'Failed to update fork remote');
    } else {
      await this.runGitOrThrow(['remote', 'add', 'fork', forkUrl], 'Failed to add fork remote');
    }

    return { owner: username, repo };
  }

  private async getGitHubUsername(): Promise<string> {
    const result = await this.runGh(['api', 'user', '-q', '.login']);
    if (!result.success) {
      throw new Error('Failed to fetch GitHub username');
    }
    return result.output.trim();
  }

  private isPermissionError(error: unknown): boolean {
    if (!(error instanceof Error)) {
      return false;
    }
    const message = error.message.toLowerCase();
    return message.includes('permission to') || message.includes('403') || message.includes('access denied');
  }

  private runCommand(
    command: string,
    args: string[],
    options: SpawnOptionsWithoutStdio = {}
  ): Promise<{ success: boolean; output: string }> {
    return new Promise((resolve) => {
      const child = spawn(command, args, {
        cwd: this.workDir,
        ...options,
      });

      let stdout = '';
      let stderr = '';

      child.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      child.on('close', (code) => {
        resolve({
          success: code === 0,
          output: stdout || stderr,
        });
      });

      child.on('error', (err) => {
        resolve({
          success: false,
          output: err.message,
        });
      });
    });
  }
}
